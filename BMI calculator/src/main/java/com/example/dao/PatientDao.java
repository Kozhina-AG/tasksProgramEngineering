package com.example.dao;

import com.example.model.Patient;
import org.jetbrains.annotations.NotNull;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * Класс PatientDao содержит методы для выполнения операций с базой данных для пациентов,
 * такие как добавление нового пациента, удаление пациента, получение всех пациентов и получение пациента по его СНИЛС.
 */

public class PatientDao{
    private static final String DB_URL = "jdbc:h2:~/patients";
    private static final String DB_USERNAME = "sa";
    private static final String DB_PASSWORD = "";
    private static final String PATIENTS_TABLE = "patients";
    private static final String FILE_PATH = "data.txt";
    private Connection connection;
    /**
     * Конструктор класса PatientDao.
     *
     * @throws IOException если возникает ошибка ввода-вывода при создании файла
     */
    public PatientDao() throws IOException {
        try {
            Class.forName("org.h2.Driver");

            connection = DriverManager.getConnection(DB_URL, DB_USERNAME, DB_PASSWORD);

            createTableIfNotExists();
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }

        File file = new File(FILE_PATH);

        file.createNewFile();
    }
    /**
     * Создает таблицу в базе данных, если она не существует.
     *
     * @throws SQLException если возникает ошибка SQL
     */
    public void createTableIfNotExists() throws SQLException {
        String sql = "CREATE TABLE IF NOT EXISTS " + PATIENTS_TABLE + " (" + "id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY," + "name VARCHAR(255) NOT NULL," + "snils VARCHAR(11) NOT NULL," + "weight DOUBLE NOT NULL," + "height DOUBLE NOT NULL," + "age INT NOT NULL," + "sex VARCHAR(7) NOT NULL" + ")";
        Statement statement = connection.createStatement();

        statement.executeUpdate(sql);
    }
    /**
     * Добавляет пациента в базу данных и возвращает его идентификатор.
     *
     * @param patient пациент для добавления
     * @return идентификатор добавленного пациента
     */
    public int addToDBAndRetrieveId(Patient patient) {
        int id = 0;

        try {
            if (connection == null)
                // Если соединение не установлено, то выкидываем исключение или инициализируем его заново
                throw new IllegalStateException("Connection has not been established");

            String sql = "INSERT INTO " + PATIENTS_TABLE + " (name, snils, weight, height, age, sex) VALUES (?, ?, ?, ?, ?, ?)";
            PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);

            preparedStatement.setString(1, patient.getName());
            preparedStatement.setString(2, patient.getSnils());
            preparedStatement.setDouble(3, patient.getWeight());
            preparedStatement.setDouble(4, patient.getHeight());
            preparedStatement.setInt(5, patient.getAge());
            preparedStatement.setString(6, patient.getSex());
            preparedStatement.executeUpdate();

            ResultSet generatedKeys = preparedStatement.getGeneratedKeys();

            generatedKeys.next();

            id = generatedKeys.getInt("id");
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return id;
    }
    /**
     * Обновляет информацию о пациенте в базе данных.
     *
     * @param patient пациент для обновления
     */
    public void updatePatientInDB(Patient patient) {
        try {
            if (connection == null)
                // Если соединение не установлено, то выкидываем исключение или инициализируем его заново
                throw new IllegalStateException("Connection has not been established");

            String sql = "UPDATE " + PATIENTS_TABLE + " SET name=?, snils=?, weight=?, height=?, age=?, sex=? WHERE id=?";
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            preparedStatement.setString(1, patient.getName());
            preparedStatement.setString(2, patient.getSnils());
            preparedStatement.setDouble(3, patient.getWeight());
            preparedStatement.setDouble(4, patient.getHeight());
            preparedStatement.setInt(5, patient.getAge());
            preparedStatement.setString(6, patient.getSex());
            preparedStatement.setInt(7, patient.getId());
            preparedStatement.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    /**
     * Удаляет пациента из базы данных.
     *
     * @param patient пациент для удаления
     */
    public void removePatientFromDB(@NotNull Patient patient) {
        try {
            String sql = "DELETE FROM " + PATIENTS_TABLE + " WHERE id=?";
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            preparedStatement.setInt(1, patient.getId());
            preparedStatement.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    /**
     * Поиск пациентов в базе данных по СНИЛСу.
     *
     * @param snils СНИЛС для поиска
     * @return список пациентов, соответствующих критерию поиска
     */
    public List<Patient> searchPatientsInDB(String snils) {
        List<Patient> patients = new ArrayList<>();

        try {
            if (connection == null)
                // Если соединение не установлено, то выкидываем исключение или инициализируем его заново
                throw new IllegalStateException("Connection has not been established");

            String sql = "SELECT * FROM patients WHERE snils LIKE ?";
            PreparedStatement preparedStatement = connection.prepareStatement(sql);

            preparedStatement.setString(1, snils);

            ResultSet resultSet = preparedStatement.executeQuery();

            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                String name = resultSet.getString("name");
                String patientSnils = resultSet.getString("snils");
                double weight = resultSet.getDouble("weight");
                double height = resultSet.getDouble("height");
                int age = resultSet.getInt("age");
                String sex = resultSet.getString("sex");
                Patient patient = new Patient(id, name, patientSnils, weight, height, age, sex);

                patients.add(patient);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return patients;
    }
    /**
     * Добавляет информацию о пациенте в файл.
     *
     * @param patient пациент для добавления
     * @param bmi     индекс массы тела
     * @throws IOException если возникает ошибка ввода-вывода
     */
    public void addPatientToFile(@NotNull Patient patient, double bmi) throws IOException {
        String text = "ФИО: " + patient.getName() + ", СНИЛС: " + patient.getSnils() + ", вес (кг): " + patient.getWeight() + ", рост (см): " + patient.getHeight() + ", возраст (лет): " + patient.getAge() + ", пол: " + patient.getSex() + ", ИМТ: " + bmi + ".\n";

        Files.write(Paths.get(FILE_PATH), text.getBytes(), StandardOpenOption.APPEND);
    }
    /**
     * Поиск пациентов в файле по СНИЛСу.
     *
     * @param snils СНИЛС для поиска
     * @return список пациентов, соответствующих критерию поиска
     */
    public List<Patient> searchPatientsInFile(String snils) {
        List<Patient> patients = new ArrayList<>();

        try (Scanner scanner = new Scanner(new File(FILE_PATH))) {
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();

                if (line.contains(snils)) {
                    String[] patientRawData = line.split(",");
                    String name = patientRawData[0].substring(patientRawData[0].indexOf(":") + 2);
                    double weight = Double.parseDouble(patientRawData[2].substring(patientRawData[2].indexOf(":") + 2));
                    double height = Double.parseDouble(patientRawData[3].substring(patientRawData[3].indexOf(":") + 2));
                    int age = Integer.parseInt(patientRawData[4].substring(patientRawData[4].indexOf(":") + 2));
                    String sex = patientRawData[5].substring(patientRawData[5].indexOf(":") + 2);

                    patients.add(new Patient(0, name, snils, weight, height, age, sex));
                }
            }
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        }

        return patients;
    }
    /**
     * Обновляет информацию о пациенте в файле.
     *
     * @param patient пациент для обновления
     * @param bmi     индекс массы тела
     * @throws IOException если возникает ошибка ввода-вывода
     */
    public void updatePatientInFile(@NotNull Patient patient, double bmi) throws IOException {
        String text = "ФИО: " + patient.getName() + ", СНИЛС: " + patient.getSnils() + ", вес (кг): " + patient.getWeight() + ", рост (см): " + patient.getHeight() + ", возраст (лет): " + patient.getAge() + ", пол: " + patient.getSex() + ", ИМТ: " + bmi + ".\n";
        Path filePath = Path.of(FILE_PATH);
        List<String> fileLines = new ArrayList<>(Files.readAllLines(filePath, StandardCharsets.UTF_8));

        for (int i = 0; i < fileLines.size(); i++)
            if (fileLines.get(i).contains(patient.getSnils())) {
                fileLines.set(i, text);

                break;
            }

        String lastLine = fileLines.get(fileLines.size() - 1);

        fileLines.remove(fileLines.size() - 1);
        Files.write(filePath, fileLines, StandardCharsets.UTF_8);
        Files.writeString(filePath, lastLine, StandardOpenOption.APPEND);
    }
    /**
     * Удаляет пациента из файла.
     *
     * @param patient пациент для удаления
     * @throws IOException если возникает ошибка ввода-вывода
     */
    public void removePatientFromFile(@NotNull Patient patient) throws IOException {
        Path filePath = Path.of(FILE_PATH);
        List<String> fileLines = new ArrayList<>(Files.readAllLines(filePath, StandardCharsets.UTF_8));

        for (int i = 0; i < fileLines.size(); i++)
            if (fileLines.get(i).contains(patient.getSnils())) {
                fileLines.remove(i);

                break;
            }

        String lastLine = fileLines.get(fileLines.size() - 1);

        fileLines.remove(fileLines.size() - 1);
        Files.write(filePath, fileLines, StandardCharsets.UTF_8);
        Files.writeString(filePath, lastLine, StandardOpenOption.APPEND);
    }
}
